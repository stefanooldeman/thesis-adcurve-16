Een van de oplossingen die wordt onderzocht is het gebruik maken van krachtige hardware componenten (zowel de CPU en de GPU). Dit is mogelijk met expert talen zoals; Verilog, CUDA of OpenCL of C++.


Op de universiteit van Standford is hier veel onderzoek gedaan. Dit vereist alleen veel hardware specifieke kennis en moet in code worden uitgedrukt: "programming these devices to run efficiently and correctly is difficult, error-prone, and results in software that is harder to read and maintain." \parencite{sujeeth2011optiml}. Daarom zijn er een serie aan DSL's ontwikkeld\footnote{Voorbeelden van van DLS's zijn \TeX, HTML en SQL  \parencite{sigplan2000dsl}}

Terwijl \textcite{sujeeth2011optiml} een veelbelovende oplossing lijkt aan te bieden is het project\footnote{Zie de website van OptiML: \url{https://stanford-ppl.github.io/Delite/optiml/index.html}} nog altijd in Alpha versie. Hetzelfde team presenteerde in 2014 Forge, een DSL voor expert talen met veelbelovende test resultaten: "Forge-generated Delite DSLs perform within 2x of hand-optimized C++ and up to 40x better than Spark, an alternative high-level distributed programming environment." \parencite{sujeeth2014forge}. Helaas lijkt hierbij hetzelfde probleem te spelen en is er niet genoeg documentatie gevonden om hier een POC mee te starten.

Binnen Shop2market zijn veel performance gerelateerde projecten opgelost met Golang. Naast dat dit erg productief is bevonden biedt de moderne taal een alternatief concurrency model. "C, C++, and to some extent Java are quite old, designed before the advent of multicore machines, networking, and web application development. There are features of the modern world that are better met by newer approaches, such as built-in concurrency." \parencite{pike2012go}.

\subsubsection{\textbf{Conclusie}}

De besproken technologieÃ«n zijn de DSL talen: OptiML, OptiSQL en Forge. Bij gebrek aan praktische voorbeelden en algemeene documentatie is er voor gekozen om hier niet verder in te investeren. Er zou niet voldoende kennis zijn om een mogelijke POC naar productie te brengen. Hoewel de Forge veelbelovende benchmarks presenteert, wordt niet vermeld welke algoritmes hierbij zijn gebruikt. Omdat in de huidige implementatie gebruik maakt van MapReduce (de Monte Carlo methode) hoeft deze performance niet behaalt te worden op een GPU. Zo schrijft \textcite{lee2010debunking}: "Monte Carlo algorithms are generally compute-bound with regular access patterns, which makes it a very good fit for SIMD architectures". Dit geeft genoeg motivatie om een POC in Golang te starten, gegeven dat het concurrency model van Golang optimaal gebruik maakt van Multicore CPU's.

\begin{table}[bh]
\caption{My caption}
\label{tab:matrix_hardware}
\begin{tabular}{|l|l|l|l|l|l|l|}
\hline
keyword    & support & scalability / performance & productief & testbaar & kennis &       \\ \hline
referentie & a (3)   & b (2)                     & c (2)      & d (1)    & e (1)  & score \\ \hline
C++        & +       & +                         & -          & -        & +      & 6     \\ \hline
Golang     & +       & +                         & +          & +        & +      & 8     \\ \hline
Forge      & -       & +                         & +          & +        & -      & 5     \\ \hline
\end{tabular}
\end{table}
