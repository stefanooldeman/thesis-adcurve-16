Een van de oplossingen die wordt onderzocht is het gebruik maken van krachtige hardware componenten (zowel de CPU en de GPU). Dit is mogelijk met expert talen zoals; Verilog, CUDA of OpenCL of C++.


Op de universiteit van Stanford is hier veel onderzoek naar gedaan. Dit vereist alleen veel hardware specifieke kennis en moet in code worden uitgedrukt: "programming these devices to run efficiently and correctly is difficult, error-prone, and results in software that is harder to read and maintain." \parencite{sujeeth2011optiml}. Daarom is er een serie aan DSL's ontwikkeld\footnote{Voorbeelden van DLS 's zijn \TeX, HTML en SQL  \parencite{sigplan2000dsl}}

Terwijl \textcite{sujeeth2011optiml} een veelbelovende oplossing lijkt aan te bieden is het project nog altijd in Alpha versie \parencite{optiml_project_home}. Hetzelfde team presenteerde in 2014 Forge, een DSL voor expert talen met veelbelovende test resultaten: "Forge-generated Delite DSLs perform within 2x of hand-optimized C++ and up to 40x better than Spark" \parencite{sujeeth2014forge}. Helaas lijkt hierbij hetzelfde probleem te spelen en is er niet genoeg documentatie gevonden om hier een POC mee te starten.

Binnen Shop2market zijn veel performance gerelateerde projecten opgelost met Golang. Naast dat dit erg productief is bevonden biedt de moderne taal een alternatief concurrency model. "C, C++, and to some extent Java are quite old, designed before the advent of multicore machines, networking, and web application development. There are features of the modern world that are better met by newer approaches, such as built-in concurrency." \parencite{pike2012go}.

\subsubsection{\textbf{Conclusie}}

De besproken technologieÃ«n zijn de DSL talen: OptiML, OptiSQL en Forge. Bij gebrek aan praktische voorbeelden en algemene documentatie is er voor gekozen om hier niet verder in te investeren. Er zou niet voldoende kennis zijn om een mogelijke POC naar productie te brengen. Hoewel Forge tijdens de benchmarks extreem goed presteert, wordt niet vermeld welke algoritmes hierbij zijn gebruikt. Omdat in de huidige implementatie gebruik wordt maakt van MapReduce (de Monte Carlo methode) hoeft deze performance niet behaalt te worden. Zo schrijft \textcite{lee2010debunking}: "Monte Carlo algorithms are generally compute-bound with regular access patterns, which makes it a very good fit for SIMD architectures", in vergelijking met een GPU processor. Golang biedt hier een mogelijke oplossing, omdat de taal een productieve manier biedt om optimaal gebruik te maken van Multicore CPU's.

\begin{table}[bh]
\caption{Vergelijkingsmatrix waarin eisen worden getoetst tegenover de gevonden programmeer talen}
\label{tab:matrix_hardware}
\begin{tabular}{|l|l|l|l|l|l|l|}
\hline
keyword    & support & scalability / performance & productief & testbaar & kennis &       \\ \hline
referentie & a (3)   & b (2)                     & c (2)      & d (1)    & e (1)  & score \\ \hline
C++        & +       & +                         & -          & -        & +      & 6     \\ \hline
Golang     & +       & +                         & +          & +        & +      & 8     \\ \hline
Forge      & -       & +                         & +          & +        & -      & 5     \\ \hline
\end{tabular}
\end{table}
